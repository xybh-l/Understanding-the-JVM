# 一、Java内存区域与内存溢出异常

## 1.运行时数据空间

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

线程共享区域：堆，方法区

线程私有区域：虚拟机栈，本地方法区，程序计数器

<img src="http://image.xybh.online/JVM运行时内存空间.png" alt="JVM运行时内存空间" style="zoom:33%; text-align=center;"/>

### 1.1 线程私有区域

#### 1.1.1 程序计数器

程序计数器是一块比较小的内存空间，它可以看作是当前线程说执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的区域。

作用：通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

如果线程正在执行的是一个Java方法，这个计数器记录的则是正在执行的虚拟机字节码指令的地址；

如果正在执行的是Native方法，这个计数器则为空（undefined）。

**程序计数器是唯一一个没有OOM的区域**

#### 1.1.2 Java虚拟机栈

Java虚拟机栈也是线程私有的,它的生命周期与线程相同。

作用：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本类型数据（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型（指向了一条字节码指令的地址）。

其中64位长度的long和double类型的数据会占用2个局部变量表空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

异常情况：1.如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常 2：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

<img src="http://image.xybh.online/Java虚拟机栈.png" alt="虚拟机栈" style="zoom:33%; text-align=center;" />

#### 1.1.3 本地方法栈

作用：本地方法栈是为虚拟机使用到的本地（Native）方法服务。

异常情况：1.如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常 2：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

### 1.2 线程共享区域

#### 1.2.1 Java堆

Java堆(Java Heap)是虚拟机所管理的内存中最大的一块区域。Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。Java堆是垃圾收集器管理的内存区域。

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。

<img src="http://image.xybh.online/堆.png" alt="堆" style="zoom:33%; text-align=center;" />

1.8开始持久代被废弃，使用元空间代替，MetaSpace并不是堆内存的一部分而是本地内存。

原因：

1. Oracle收购JRockit，合并HotSpot和JRockit，而JRockit虚拟机中没有永久代的概念。
2. 持久代空间大小很难确定，太小容易GC/OOM异常、太大占空间（而元空间并不在虚拟机中、而是使用本地内存，大小仅受本场内存限制）
3. 持久代调优困难
4. 垃圾回收频率低

#### 1.2.2 方法区

方法区与Java堆一样,是各个线程共享的内存区域，它用于存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

JDK8以后改用在本地内存中实现的元空间。

| jdk版本      | 变化                                                         |
| ------------ | ------------------------------------------------------------ |
| jdk1.6及之前 | 有永久代(permanent generation),静态变量保存在永久代上        |
| jdk1.7       | 有永久代,但已经逐步”去永久代“，字符串常量池、静态变量移除，保存在堆中 |
| jdk1.8及之后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，当字符串常量池和静态变量任保存在堆 |



<img src="http://image.xybh.online/方法区-1.6.png" alt="方法区在JDK1.6中的实现" style="zoom: 50%;" />

<img src="http://image.xybh.online/方法区-1.7.png" alt="方法区在JDK1.7中的实现" style="zoom:50%;" />

<img src="http://image.xybh.online/方法区-1.8.png" alt="方法区在JDK1.8中的实现" style="zoom:50%;" />

异常：如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

**方法区中还存在三种常量池：静态常量池、运行时常量池、字符串常量池**

1. 常量池-静态常量池

- 也叫作class文件常量池,主要存放:
  - 字面量:例如文本字符串、final修饰的变量
  - 符号引用：例如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

2. 常量池-运行时常量池

- 当类加载到内存中后，JVM就会将静态常量池中的内容存放到运行时常量池中；运行时常量池里面存储的主要是编译期间生成的字面量、符号引用等
- 如String类的intern()方法

3. 常量池-字符串常量池

- 可以理解成运行时常量池分出来的一部分，类加载到内存的时候，字符串会存到字符串常量池里面

## 2.HotSpot虚拟机对象
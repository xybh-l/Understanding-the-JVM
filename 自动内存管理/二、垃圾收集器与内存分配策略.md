# 二、垃圾收集器和内存分配机制

## 1.垃圾收集

### 1.1 垃圾回收策略

- 对内存要求苛刻的场景:想办法提高对象的回收效率，多回收掉一些对象，腾出更多内存
- 在CPU使用率高的情况下：降低高并发时垃圾回收的频率，让CPU更多地去执行业务而不是垃圾回收

### 1.2 垃圾回收区域

堆:回收对象

方法区:回收常量和类(回收频率低)



### 1.3 对象回收的时机

#### 1.3.1 引用计数算法

> 在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器值就减一;任何时候计数器值为零的对象就是不可能再被使用的。

<img src="http://image.xybh.online/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="引用计数法" style="zoom: 67%;" />

**引用计数法无效情况（循环引用）：**

<center><img src="http://image.xybh.online/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A81.png" alt="引用计数法循环引用1" style="zoom: 67%;" /><img src="http://image.xybh.online/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82.png" alt="引用计数法循环引用2" style="zoom: 67%;" /></center>

Java不采用

#### 1.3.2 可达性分析算法

基本思路:通过一系列称为"GC Roots"的根对象作为初始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。

<img src="http://image.xybh.online/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法" style="zoom:50%;" />

**GC Roots的对象**

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI引用的对象
5. 虚拟机内部的引用
6. 所有被同步锁持有的对象

### 1.4 引用 

JDK1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。

JDK1.2后：将引用分为强引用、软引用、弱引用、虚引用

#### 1.4.1 强引用

> 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

- `Object object = new Object()`
- 只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象

#### 1.4.2 软引用

> 用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列入进回收范围之中进行第二次回收。

- `SoftReference<String> sr = new SoftReference<>("hello");`
- 用来描述一些有用但非必须的对象
- 只有在内存不足的时候才会回收
- 可用于实现缓存

#### 1.4.3 弱引用

> 用来描述那些非必须对象，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论内存是否充足，都会回收掉只被弱引用关联的对象。

- `WeakReference<String> sr = new WeakReference<>("hello")`
- 弱引用也是用来描述非必须的对象
- 无论内存是否充足，都会被垃圾收集器回收

#### 1.4.4 虚引用

> 虚引用也成为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取消一个对象实例。唯一目的只是能在这个对象被收集器回收的时候收到一个通知

- `ReferenceQueue<String> queue = new ReferenceQueue<>();`

  `PhantomReference<String> pr = new PhantomReference<>('hello', queue);`

- 不影响对象的生命周期，如果一个对象**只有**虚引用，那么它就和没有任何引用一样，在任何时候都可以被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，必须要和引用队列配合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动


# 二、垃圾收集器和内存分配机制

## 1.垃圾收集

### 1.1 垃圾回收策略

- 对内存要求苛刻的场景:想办法提高对象的回收效率，多回收掉一些对象，腾出更多内存
- 在CPU使用率高的情况下：降低高并发时垃圾回收的频率，让CPU更多地去执行业务而不是垃圾回收

### 1.2 垃圾回收区域

堆:回收对象

方法区:回收常量和类(回收频率低)



### 1.3 对象回收的时机

#### 1.3.1 引用计数算法

> 在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器值就减一;任何时候计数器值为零的对象就是不可能再被使用的。

<img src="http://image.xybh.online/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="引用计数法" style="zoom: 67%;" />

**引用计数法无效情况（循环引用）：**

<center><img src="http://image.xybh.online/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A81.png" alt="引用计数法循环引用1" style="zoom: 67%;" /><img src="http://image.xybh.online/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82.png" alt="引用计数法循环引用2" style="zoom: 67%;" /></center>

Java不采用

#### 1.3.2 可达性分析算法

基本思路:通过一系列称为"GC Roots"的根对象作为初始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。

<img src="http://image.xybh.online/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="image-20210209163303952" style="zoom:50%;" />

**GC Roots的对象**

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI引用的对象
5. 虚拟机内部的引用
6. 所有被同步锁持有的对象
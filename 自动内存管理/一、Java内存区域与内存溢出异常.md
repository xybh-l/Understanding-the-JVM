# 一、Java内存区域与内存溢出异常

## 1.运行时数据空间

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

线程共享区域：堆，方法区

线程私有区域：虚拟机栈，本地方法区，程序计数器

<img src="http://image.xybh.online/JVM运行时内存空间.png" alt="JVM运行时内存空间" style="zoom:33%; text-align=center;"/>

### 1.1 线程私有区域

#### 1.1.1 程序计数器

程序计数器是一块比较小的内存空间，它可以看作是当前线程说执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的区域。

作用：通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

如果线程正在执行的是一个Java方法，这个计数器记录的则是正在执行的虚拟机字节码指令的地址；

如果正在执行的是Native方法，这个计数器则为空（undefined）。

**程序计数器是唯一一个没有OOM的区域**

#### 1.1.2 Java虚拟机栈

Java虚拟机栈也是线程私有的,它的生命周期与线程相同。

作用：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本类型数据（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型（指向了一条字节码指令的地址）。

其中64位长度的long和double类型的数据会占用2个局部变量表空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

异常情况：1.如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常 2：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

<img src="http://image.xybh.online/Java虚拟机栈.png" alt="虚拟机栈" style="zoom:33%; text-align=center;" />

#### 1.1.3 本地方法栈

作用：本地方法栈是为虚拟机使用到的本地（Native）方法服务。

异常情况：1.如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常 2：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

### 1.2 线程共享区域

#### 1.2.1 Java堆

Java堆(Java Heap)是虚拟机所管理的内存中最大的一块区域。Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。Java堆是垃圾收集器管理的内存区域。

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。

<img src="http://image.xybh.online/堆.png" alt="堆" style="zoom:33%; text-align=center;" />

1.8开始持久代被废弃，使用元空间代替，MetaSpace并不是堆内存的一部分而是本地内存。

原因：

1. Oracle收购JRockit，合并HotSpot和JRockit，而JRockit虚拟机中没有永久代的概念。
2. 持久代空间大小很难确定，太小容易GC/OOM异常、太大占空间（而元空间并不在虚拟机中、而是使用本地内存，大小仅受本场内存限制）
3. 持久代调优困难
4. 垃圾回收频率低

#### 1.2.2 方法区

方法区与Java堆一样,是各个线程共享的内存区域，它用于存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

JDK8以后改用在本地内存中实现的元空间。

| jdk版本      | 变化                                                         |
| ------------ | ------------------------------------------------------------ |
| jdk1.6及之前 | 有永久代(permanent generation),静态变量保存在永久代上        |
| jdk1.7       | 有永久代,但已经逐步”去永久代“，字符串常量池、静态变量移除，保存在堆中 |
| jdk1.8及之后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，当字符串常量池和静态变量任保存在堆 |



<img src="http://image.xybh.online/方法区-1.6.png" alt="方法区在JDK1.6中的实现" style="zoom: 50%;" />

<img src="http://image.xybh.online/方法区-1.7.png" alt="方法区在JDK1.7中的实现" style="zoom:50%;" />

<img src="http://image.xybh.online/方法区-1.8.png" alt="方法区在JDK1.8中的实现" style="zoom:50%;" />

异常：如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

**方法区中还存在三种常量池：静态常量池、运行时常量池、字符串常量池**

1. 常量池-静态常量池

- 也叫作class文件常量池,主要存放:
  - 字面量:例如文本字符串、final修饰的变量
  - 符号引用：例如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

2. 常量池-运行时常量池

- 当类加载到内存中后，JVM就会将静态常量池中的内容存放到运行时常量池中；运行时常量池里面存储的主要是编译期间生成的字面量、符号引用等
- 如String类的intern()方法

3. 常量池-字符串常量池

- 可以理解成运行时常量池分出来的一部分，类加载到内存的时候，字符串会存到字符串常量池里面

## 2.HotSpot虚拟机对象

### 2.1 对象的创建

```mermaid
graph LR
	A["类加载检查"]
 	B["分配内存空间"] 
 	C["内存空间初始化为0"]
 	D["对对象进行必要的设置"]
     A-->B
     B-->C
     C-->D
```

#### ①类加载检查

当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有那必须先执行相应的类加载过程。

#### ②分配内存空间

1. **指针碰撞：**假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。
2. **空闲列表：**如果Java堆中的内存并不是规整的，已被使用的内存和空闲内存相互交错在一起,虚拟机就必须维护一个列表,记录哪些内存块是可用的,在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录。

> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由说采用的垃圾收集器采用的是方法是否带有空间压缩整理（Compact）的能力决定。带有标记-整理算法的垃圾收集器一般采用指针碰撞，使用基于清除算法的收集器，理论上就只能采用空闲列表来分配空间。

保证多线程下的内存分配安全：

1. 对分配内存空间的动作进行同步处理----CAS+失败重试保证更新操作的原子性。
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。本地线程分配缓存（TLAB， Thread Local Allocation Buffer）

#### ③对对象进行设置

1. 初始化零值

   内存分配完成之后,虚拟机必须将分配到的内存空间(不包括对象头)都初始化为零值。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，使程序能访问到这些字段的数据类型所对应的零值。

2. 对对象头设置

   这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄。另外根据虚拟机当前运行状态的不同，如是否启用偏向锁等。

#### ④执行Init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的角度看来，对象创建才刚刚开始————构造函数，即Class文件中的\<init\>()方法还没有执行,所有的字段都为默认的零值,对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般之行为\<init\>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

### 2.2 对象的内存布局

在HotSpot虚拟机中对象的内存布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）

**对象头包括两部分信息：**

1. 存储对象自身的运行时数据（如：哈希码、GC分代年龄、锁 等）
2. 类型指针（即对象指向他的类元数据的指针，虚拟机根据此指针来确认对象属于哪个类的实例）

**实例数据：**

　　实例数据才是对象真正存贮的有效信息（即程序中所定义的各种类型的字段内容）。

**对齐填充：**

　　不是必然存在的，仅仅起到占位符的作用。

### 2.3 对象的访问定向

对象访问方式由虚拟机实现而定,主流的访问方式主要有两种:使用句柄和直接指针

- 如果使用句柄访问的话,Java堆中将可能会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

  <img src="http://image.xybh.online/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="句柄访问" style="zoom:33%;" />

- 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问。

  <img src="http://image.xybh.online/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" alt="直接指针访问" style="zoom:33%;" />

> 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。




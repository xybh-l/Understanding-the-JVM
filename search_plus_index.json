{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 学习《深入理解Java虚拟机》的总结以及一些博客的摘录 powered by Gitbook该文件最后修改时间： 2021-03-03 15:15:21 "},"自动内存管理/一、Java内存区域与内存溢出异常.html":{"url":"自动内存管理/一、Java内存区域与内存溢出异常.html","title":"一、Java内存区域与内存溢出异常","keywords":"","body":"一、Java内存区域与内存溢出异常 1.运行时数据空间 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。 线程共享区域：堆，方法区 线程私有区域：虚拟机栈，本地方法区，程序计数器 1.1 线程私有区域 1.1.1 程序计数器 程序计数器是一块比较小的内存空间，它可以看作是当前线程说执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的区域。 作用：通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 如果线程正在执行的是一个Java方法，这个计数器记录的则是正在执行的虚拟机字节码指令的地址； 如果正在执行的是Native方法，这个计数器则为空（undefined）。 程序计数器是唯一一个没有OOM的区域 1.1.2 Java虚拟机栈 Java虚拟机栈也是线程私有的,它的生命周期与线程相同。 作用：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本类型数据（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量表空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 异常情况：1.如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常 2：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 1.1.3 本地方法栈 作用：本地方法栈是为虚拟机使用到的本地（Native）方法服务。 异常情况：1.如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常 2：如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 1.2 线程共享区域 1.2.1 Java堆 Java堆(Java Heap)是虚拟机所管理的内存中最大的一块区域。Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。Java堆是垃圾收集器管理的内存区域。 根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。 1.8开始持久代被废弃，使用元空间代替，MetaSpace并不是堆内存的一部分而是本地内存。 原因： Oracle收购JRockit，合并HotSpot和JRockit，而JRockit虚拟机中没有永久代的概念。 持久代空间大小很难确定，太小容易GC/OOM异常、太大占空间（而元空间并不在虚拟机中、而是使用本地内存，大小仅受本场内存限制） 持久代调优困难 垃圾回收频率低 1.2.2 方法区 方法区与Java堆一样,是各个线程共享的内存区域，它用于存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 JDK8以后改用在本地内存中实现的元空间。 jdk版本 变化 jdk1.6及之前 有永久代(permanent generation),静态变量保存在永久代上 jdk1.7 有永久代,但已经逐步”去永久代“，字符串常量池、静态变量移除，保存在堆中 jdk1.8及之后 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，当字符串常量池和静态变量任保存在堆 异常：如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 方法区中还存在三种常量池：静态常量池、运行时常量池、字符串常量池 常量池-静态常量池 也叫作class文件常量池,主要存放: 字面量:例如文本字符串、final修饰的变量 符号引用：例如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符 常量池-运行时常量池 当类加载到内存中后，JVM就会将静态常量池中的内容存放到运行时常量池中；运行时常量池里面存储的主要是编译期间生成的字面量、符号引用等 如String类的intern()方法 常量池-字符串常量池 可以理解成运行时常量池分出来的一部分，类加载到内存的时候，字符串会存到字符串常量池里面 2.HotSpot虚拟机对象 2.1 对象的创建 graph LR A[\"类加载检查\"] B[\"分配内存空间\"] C[\"内存空间初始化为0\"] D[\"对对象进行必要的设置\"] A-->B B-->C C-->D ①类加载检查 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有那必须先执行相应的类加载过程。 ②分配内存空间 指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。 空闲列表：如果Java堆中的内存并不是规整的，已被使用的内存和空闲内存相互交错在一起,虚拟机就必须维护一个列表,记录哪些内存块是可用的,在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由说采用的垃圾收集器采用的是方法是否带有空间压缩整理（Compact）的能力决定。带有标记-整理算法的垃圾收集器一般采用指针碰撞，使用基于清除算法的收集器，理论上就只能采用空闲列表来分配空间。 保证多线程下的内存分配安全： 对分配内存空间的动作进行同步处理----CAS+失败重试保证更新操作的原子性。 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。本地线程分配缓存（TLAB， Thread Local Allocation Buffer） ③对对象进行设置 初始化零值 内存分配完成之后,虚拟机必须将分配到的内存空间(不包括对象头)都初始化为零值。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，使程序能访问到这些字段的数据类型所对应的零值。 对对象头设置 这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄。另外根据虚拟机当前运行状态的不同，如是否启用偏向锁等。 ④执行Init方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的角度看来，对象创建才刚刚开始————构造函数，即Class文件中的\\()方法还没有执行,所有的字段都为默认的零值,对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般之行为\\()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。 2.2 对象的内存布局 在HotSpot虚拟机中对象的内存布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding） 对象头包括两部分信息： 存储对象自身的运行时数据（如：哈希码、GC分代年龄、锁 等） 类型指针（即对象指向他的类元数据的指针，虚拟机根据此指针来确认对象属于哪个类的实例） 实例数据： 　　实例数据才是对象真正存贮的有效信息（即程序中所定义的各种类型的字段内容）。 对齐填充： 　　不是必然存在的，仅仅起到占位符的作用。 2.3 对象的访问定向 对象访问方式由虚拟机实现而定,主流的访问方式主要有两种:使用句柄和直接指针 如果使用句柄访问的话,Java堆中将可能会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问。 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。 powered by Gitbook该文件最后修改时间： 2021-03-03 15:15:21 "},"自动内存管理/二、垃圾收集器与内存分配策略.html":{"url":"自动内存管理/二、垃圾收集器与内存分配策略.html","title":"二、垃圾收集器与内存分配策略","keywords":"","body":"二、垃圾收集器和内存分配机制 1.内存分配机制 1.1 垃圾回收策略 对内存要求苛刻的场景:想办法提高对象的回收效率，多回收掉一些对象，腾出更多内存 在CPU使用率高的情况下：降低高并发时垃圾回收的频率，让CPU更多地去执行业务而不是垃圾回收 1.2 垃圾回收区域 堆:回收对象 方法区:回收常量和类(回收频率低) 1.3 对象回收的时机 1.3.1 引用计数算法 在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器值就减一;任何时候计数器值为零的对象就是不可能再被使用的。 引用计数法无效情况（循环引用）： 1.3.2 可达性分析算法 基本思路:通过一系列称为\"GC Roots\"的根对象作为初始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。 GC Roots的对象 虚拟机栈(栈帧中的本地变量表)中引用的对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中JNI引用的对象 虚拟机内部的引用 所有被同步锁持有的对象 可达性算法注意点 一个对象即使不可达，也不一定会被回收 finalize()优先级低，何时会被调用无法确定，因为什么时间发生GC不确定 尽量不使用finalize()来拯救对象，使用try-catch-finally来进行替换 1.4 引用 JDK1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。 JDK1.2后：将引用分为强引用、软引用、弱引用、虚引用 1.4.1 强引用 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 Object object = new Object() 只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象 1.4.2 软引用 用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列入进回收范围之中进行第二次回收。 SoftReference sr = new SoftReference<>(\"hello\"); 用来描述一些有用但非必须的对象 只有在内存不足的时候才会回收 可用于实现缓存 1.4.3 弱引用 用来描述那些非必须对象，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论内存是否充足，都会回收掉只被弱引用关联的对象。 WeakReference sr = new WeakReference<>(\"hello\") 弱引用也是用来描述非必须的对象 无论内存是否充足，都会被垃圾收集器回收 1.4.4 虚引用 虚引用也成为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取消一个对象实例。唯一目的只是能在这个对象被收集器回收的时候收到一个通知 ReferenceQueue queue = new ReferenceQueue<>(); PhantomReference pr = new PhantomReference<>('hello', queue); 不影响对象的生命周期，如果一个对象只有虚引用，那么它就和没有任何引用一样，在任何时候都可以被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，必须要和引用队列配合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动 1.5 垃圾收集算法 1.5.1 标记-清除算法（Mark-Sweep) 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收未被标记的对象。 缺点： 执行效率不稳定 - 如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的操作，导致标记和清除两个过程的执行效率都随着对象数量增长而降低 内存空间碎片化 - 标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发一次垃圾收集动作 1.5.2 标记-复制算法（Mark-Copy） 它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活的对象复制到另外一块上买了，然后再把已使用过的内存空间一次处理掉。 缺点： 将可用内存缩小为了原来的一半 标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接使用这种算法 1.5.3 标记-整理（Mark-Compact） 标记过程仍然和标记-清除算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。 缺点： 移动存活对象需要开销，尤其是在老年代这种每次回收都有大量对象存活区域，而且移动老年代区域对象需要全程暂停用户应用程序才能进行。 回收算法 优点 缺点 标记-清除 实现简单 1.空间碎片化2.标记和清除时间随对象数量增长而增加 性能好、无碎片 1.空间利用率低 无碎片 1.开销大 1.5.4 分代收集算法 基于两个分代假说之上: 弱分代假说:绝大多数对象都是朝生夕灭的 强分代假说:熬过越多次垃圾收集过程的对象就越难以消亡 收集器将Java堆划分出两个不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾回收过程的次数）分配到不同的区域之中存储。 回收类型 新生代回收（Minor GC | Young GC） 老年代回收（Major GC) 清理整个堆（Full GC） Major GC ≈ Full GC 根据不同的区域安排与里面存储对象存亡特征相匹配的垃圾回收算法 新生代一般采用标记-复制算法,Eden:Survivor=8:1,当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要其他内存区域（大多为老年代）进行分配担保，即如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代。 老年代一般采用标记-清除或标记-整理算法。 重点 新建的对象不一定分配到Eden区 对象大于-XX：PretenureSizeThreshold，就会直接分配到老年代 新生代空间不足，分配担保直接进入老年代 对象不一定要达到年龄才进入老年代 动态年龄：如果Survivor空间中所有相同年龄对象大小的总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就可以直接进入老年代 触发垃圾回收的条件 新生代(Minor GC) Eden空间不足 老年代(Full GC) 老年代空间不足(空间实际不足或内存碎片过多) 元空间不足 要晋升到老年代的对象说要占用的空间大于老年代的剩余空间 调用System.gc() 分代的好处 更有效的清除不再需要的对象 提升了垃圾回收的效率 分代收集算法调优的原则 合理设置Survivor区的大小，避免内存浪费 让GC尽量发生在新生代，尽量减少Full GC的发生 2.垃圾收集器 2.1 Serial收集器 Serial收集器是最基础、历史最悠久的收集器。它是一个单线程工作的收集器，它在进行垃圾收集时，必须暂停其他所有工作线程，直至它收集完成（STW， Stop The World)。 新生代使用标记-复制算法 优点: 所有收集器中额外内存消耗最小的 可以获得最高的单线程收集效率 2.2 ParNew收集器 实质上是Serial收集器的多线程并发版本,除了支持多线程并发收集之外，其他与Serial收集器相比并没有太多创新之处。常与CMS结合使用。 新生代用多条线程使用复制算法 2.3 Parallel Scavenge收集器 目标是达到一个可控制的吞吐量。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。 2.4 Serial Old收集器 Serial Old是Serial收集器的老年代版本,它同样是个单线程收集器。 标记-整理算法 作为CMS收集器发生失败后的后备预案，在并发收集发生Concurrent Mode Failure时使用。 2.5 Paraller Old收集器 Parallel Old是Parallel收集器的老年代版本，支持多线程并发收集。适合与Parallel收集器在注重吞吐量或者处理器资源比较稀缺的场合使用。 基于标记-整理算法 2.6 CMS(Concurrent Mark Sweep)收集器 是一种以获得最短回收停顿时间为目标的收集器。 运用于老年代，使用标记-清除算法 GC过程： 初始标记(STW)-并发标记-重新标记(STW)-并发清除-重置线程 会产生浮动垃圾,导致GC失败而导致另一次完全的\"STW\"的Full GC的产生,这时候会使用Serial Old收集器来重新进行老年代的垃圾收集。 powered by Gitbook该文件最后修改时间： 2021-03-03 15:15:21 "}}